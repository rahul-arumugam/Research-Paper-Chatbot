ColBERT: Efficient and Effective Passage Search viaContextualized Late Interaction over BERTOmar KhattabStanford Universityokhattab@stanford.eduMatei ZahariaStanford Universitymatei@cs.stanford.eduABSTRACTRecent progress in Natural Language Understanding (NLU) is driv-ing fast-paced advances in Information Retrieval (IR), largely owedto fine-tuning deep language models (LMs) for document ranking.While remarkably effective, the ranking models based on these LMsincrease computational cost by orders of magnitude over prior ap-proaches, particularly as they must feed each queryâ€“document pairthrough a massive neural network to compute a single relevancescore. To tackle this, we present ColBERT, a novel ranking modelthat adapts deep LMs (in particular, BERT) for efficient retrieval.ColBERT introduces a late interaction architecture that indepen-dently encodes the query and the document using BERT and thenemploys a cheap yet powerful interaction step that models their fine-grained similarity. By delaying and yet retaining this fine-granularinteraction, ColBERT can leverage the expressiveness of deep LMswhile simultaneously gaining the ability to pre-compute documentrepresentations offline, considerably speeding up query processing.Crucially, ColBERTâ€™s pruning-friendly interaction mechanism en-ables leveraging vector-similarity indexes for end-to-end retrievaldirectly from millions of documents. We extensively evaluate Col-BERT using two recent passage search datasets. Results show thatColBERTâ€™s effectiveness is competitive with existing BERT-basedmodels (and outperforms every non-BERT baseline), while exe-cuting two orders-of-magnitude faster and requiring up to fourorders-of-magnitude fewer FLOPs per query.KEYWORDSNeural IR; Efficiency; Deep Language Models; BERTACM Reference Format:Omar Khattab and Matei Zaharia. 2020. ColBERT: Efficient and Effective Pas-sage Search via Contextualized Late Interaction over BERT. In Proceedings ofthe 43rd International ACM SIGIR Conference on Research and Development inInformation Retrieval (SIGIR â€™20), July 25â€“30, 2020, Virtual Event, China. ACM,New York, NY, USA, 10 pages. https://doi.org/10.1145/3397271.34010751 INTRODUCTIONOver the past few years, the Information Retrieval (IR) communityhas witnessed the introduction of a host of neural ranking models,including DRMM [ 7], KNRM [ 4,36], and Duet [ 20,22]. In contrastPermission to make digital or hard copies of all or part of this work for personal orclassroom use is granted without fee provided that copies are not made or distributedfor profit or commercial advantage and that copies bear this notice and the full citationon the first page. Copyrights for components of this work owned by others than theauthor(s) must be honored. Abstracting with credit is permitted. To copy otherwise, orrepublish, to post on servers or to redistribute to lists, requires prior specific permissionand/or a fee. Request permissions from permissions@acm.org.SIGIR â€™20, July 25â€“30, 2020, Virtual Event, ChinaÂ©2020 Copyright held by the owner/author(s). Publication rights licensed to ACM.ACM ISBN 978-1-4503-8016-4/20/07. . . $15.00https://doi.org/10.1145/3397271.34010750.15 0.20 0.25 0.30 0.35 0.40MRR@10101102103104105Query Latency (ms)BM25doc2queryKNRMDuetDeepCTfT+ConvKNRMdocTTTTTqueryBERT-baseBERT-largeColBERT (re-rank)ColBERT (full retrieval)Bag-of-Words (BoW) ModelBoW Model with NLU AugmentationNeural Matching ModelDeep Language ModelColBERT (ours)Figure 1: Effectiveness (MRR@10) versus Mean Query La-tency (log-scale) for a number of representative rankingmodels on MS MARCO Ranking [24]. The figure also showsColBERT. Neural re-rankers run on top of the official BM25top-1000 results and use a Tesla V100 GPU. Methodology anddetailed results are in Â§4.to prior learning-to-rank methods that rely on hand-crafted fea-tures, these models employ embedding-based representations ofqueries and documents and directly model local interactions (i.e.,fine-granular relationships) between their contents. Among them,a recent approach has emerged that fine-tunes deep pre-trainedlanguage models (LMs) like ELMo [ 29] and BERT [ 5] for estimatingrelevance. By computing deeply-contextualized semantic repre-sentations of queryâ€“document pairs, these LMs help bridge thepervasive vocabulary mismatch [ 21,42] between documents andqueries [ 30]. Indeed, in the span of just a few months, a numberof ranking models based on BERT have achieved state-of-the-artresults on various retrieval benchmarks [ 3,18,25,39] and havebeen proprietarily adapted for deployment by Google1and Bing2.However, the remarkable gains delivered by these LMs comeat a steep increase in computational cost. HofstÃ¤tter et al. [9] andMacAvaney et al. [18] observe that BERT-based models in the lit-erature are 100-1000 Ã—more computationally expensive than priormodelsâ€”some of which are arguably notinexpensive to begin with[13]. This qualityâ€“cost tradeoff is summarized by Figure 1, whichcompares two BERT-based rankers [ 25,27] against a representativeset of ranking models. The figure uses MS MARCO Ranking [ 24],a recent collection of 9M passages and 1M queries from Bingâ€™slogs. It reports retrieval effectiveness (MRR@10) on the officialvalidation set as well as average query latency (log-scale) using ahigh-end server that dedicates one Tesla V100 GPU per query forneural re-rankers. Following the re-ranking setup of MS MARCO,ColBERT (re-rank), the Neural Matching Models, and the Deep LMsre-rank MS MARCOâ€™s official top-1000 documents per query. Other1https://blog.google/products/search/search-language-understanding-bert/2https://azure.microsoft.com/en-us/blog/bing-delivers-its-largest-improvement-in-search-experience-using-azure-gpus/Session 1A: NeuIR and Semantic Matching  SIGIR â€™20, July 25â€“30, 2020, Virtual Event, China39Query DocumentMaxSimâˆ‘MaxSim MaxSimsQueryCNN  /  Match KernelsCNN  /  Match Kernels / MLPMLPsDocument(c) All-to-all Interaction(e.g., BERT)(b) Query-Document Interaction(e.g., DRMM, KNRM, Conv-KNRM)(d) Late Interaction(i.e., the proposed ColBERT)(a) Representation-based Similarity(e.g., DSSM, SNRM)Query DocumentsQuery DocumentsFigure 2: Schematic diagrams illustrating queryâ€“document matching paradigms in neural IR. The figure contrasts existingapproaches (sub-figures (a), (b), and (c)) with the proposed late interaction paradigm (sub-figure (d)).methods, including ColBERT (full retrieval), directly retrieve thetop-1000 results from the entire collection.As the figure shows, BERT considerably improves search preci-sion, raising MRR@10 by almost 7% against the best previous meth-ods; simultaneously, it increases latency by up to tens of thousandsof milliseconds even with a high-end GPU. This poses a challengingtradeoff since raising query response times by as little as 100ms isknown to impact user experience and even measurably diminishrevenue [ 17]. To tackle this problem, recent work has started explor-ing using Natural Language Understanding (NLU) techniques toaugment traditional retrieval models like BM25 [ 32]. For example,Nogueira et al. [26,28] expand documents with NLU-generatedqueries before indexing with BM25 scores and Dai & Callan [ 2] re-place BM25â€™s term frequency with NLU-estimated term importance.Despite successfully reducing latency, these approaches generallyreduce precision substantially relative to BERT.To reconcile efficiency and contextualization in IR, we proposeColBERT , a ranking model based on contextualized late interac-tion over BERT . As the name suggests, ColBERT proposes a novellate interaction paradigm for estimating relevance between a queryğ‘and a document ğ‘‘. Under late interaction, ğ‘andğ‘‘are separatelyencoded into two sets of contextual embeddings, and relevance isevaluated using cheap and pruning-friendly computations betweenboth setsâ€”that is, fast computations that enable ranking withoutexhaustively evaluating every possible candidate.Figure 2 contrasts our proposed late interaction approach withexisting neural matching paradigms. On the left, Figure 2 (a) illus-trates representation-focused rankers, which independently computean embedding for ğ‘and another for ğ‘‘and estimate relevance asa single similarity score between two vectors [ 12,41]. Moving tothe right, Figure 2 (b) visualizes typical interaction-focused rankers.Instead of summarizing ğ‘andğ‘‘into individual embeddings, theserankers model word- and phrase-level relationships across ğ‘andğ‘‘and match them using a deep neural network (e.g., with CNNs/MLPs[22] or kernels [ 36]). In the simplest case, they feed the neural net-work an interaction matrix that reflects the similiarity betweenevery pair of words across ğ‘andğ‘‘. Further right, Figure 2 (c) illus-trates a more powerful interaction-based paradigm, which modelsthe interactions between words within as well as acrossğ‘andğ‘‘atthe same time, as in BERTâ€™s transformer architecture [25].These increasingly expressive architectures are in tension. Whileinteraction-based models (i.e., Figure 2 (b) and (c)) tend to be su-perior for IR tasks [ 8,21], a representation-focused modelâ€”by iso-lating the computations among ğ‘andğ‘‘â€”makes it possible to pre-compute document representations offline [ 41], greatly reducingthe computational load per query. In this work, we observe thatthe fine-grained matching in interaction-based models and the pre-computation in representation-based models can be combined byretaining yet judiciously delaying the queryâ€“document interaction.Figure 2 (d) illustrates an architecture that precisely does so. Asillustrated, every query embedding interacts with all documentembeddings via a MaxSim operator, which computes maximumsimilarity (e.g., cosine), and the scalar outputs of these operatorsare summed across query terms. This paradigm allows ColBERT toexploit deep LM-based representations while shifting the cost ofencoding documents offline and amortizing the cost of encodingthe query once across all ranked documents. Crucially, it enablesColBERT to leverage vector-similarity search indexes (e.g., [ 1,15])to retrieve the top- ğ‘˜results directly from a large document collec-tion. This ability substantially improves recall over existing models,which only re-rank the output of term-based retrieval.As Figure 1 illustrates, ColBERT can serve queries in tens or, forend-to-end retrieval from millions of documents, few hundreds ofmilliseconds. For instance, when used for re-ranking as in â€œColBERT(re-rank)â€, it delivers over 170 Ã—speedup (and requires 14,000 Ã—fewerFLOPs) relative to existing BERT-based models [ 25,27], while be-ing more effective than every non-BERT baseline (Â§4.2 & 4.3). Col-BERTâ€™s indexingâ€”the only time it needs to feed documents throughBERTâ€”is also practical: it can index the MS MARCO collection of9M passages in about 3 hours using a single server with four GPUs(Â§4.5), retaining its effectiveness with a space footprint of as littleas few tens of GiBs. Our ablation study (Â§4.4) shows that late in-teraction, its implementation via MaxSim operations, and crucialdesign choices within our BERT-based encoders are all essential toColBERTâ€™s effectiveness.Our main contributions are as follows.(1)We propose late interaction (Â§3.1) as a paradigm for efficientand effective neural ranking.(2)We present ColBERT (Â§3.2 & 3.3), a highly-effective modelthat employs novel BERT-based query and document en-coders within the late interaction paradigm.Session 1A: NeuIR and Semantic Matching  SIGIR â€™20, July 25â€“30, 2020, Virtual Event, China40(3)We show how to leverage ColBERT both for re-ranking ontop of a term-based retrieval model (Â§3.5) and for searchinga full collection using vector similarity indexes (Â§3.6).(4)We evaluate ColBERT on MS MARCO and TREC CAR, tworecent passage search collections.We release our reference implementation as open source.32 RELATED WORKNeural Matching Models. Over the past few years, IR researchershave introduced numerous neural architectures for ranking. Inthis work, we compare against KNRM [ 4,36], Duet [ 20,22], Con-vKNRM [ 4], and fastText+ConvKNRM [ 10]. KNRM proposes a dif-ferentiable kernel-pooling technique for extracting matching sig-nals from an interaction matrix, while Duet combines signals fromexact-match-based as well as embedding-based similarities for rank-ing. Introduced in 2018, ConvKNRM learns to match ğ‘›-grams in thequery and the document. Lastly, fastText+ConvKNRM (abbreviatedfT+ConvKNRM) tackles the absence of rare words from typicalword embeddings lists by adopting sub-word token embeddings.In 2018, Zamani et al. [41] introduced SNRM, a representation-focused IR model that encodes each query and each document asa single, sparse high-dimensional vector of â€œlatent termsâ€. By pro-ducing a sparse-vector representation for each document, SNRMis able to use a traditional IR inverted index for representing docu-ments, allowing fast end-to-end retrieval. Despite highly promisingresults and insights, SNRMâ€™s effectiveness is substantially outper-formed by the state of the art on the datasets with which it wasevaluated (e.g., see [ 18,38]). While SNRM employs sparsity to al-low using inverted indexes, we relax this assumption and comparea (dense) BERT-based representation-focused model against ourlate-interaction ColBERT in our ablation experiments in Â§4.4. For adetailed overview of existing neural ranking models, we refer thereaders to two recent surveys of the literature [8, 21].Language Model Pretraining for IR. Recent work in NLUemphasizes the importance pre-training language representationmodels in an unsupervised fashion before subsequently fine-tuningthem on downstream tasks. A notable example is BERT [ 5], a bi-directional transformer-based language model whose fine-tuningadvanced the state of the art on various NLU benchmarks. Nogueira etal.[25], MacAvaney et al. [18], and Dai & Callan [ 3] investigateincorporating such LMs (mainly BERT, but also ELMo [ 29]) on dif-ferent ranking datasets. As illustrated in Figure 2 (c), the commonapproach (and the one adopted by Nogueira et al. on MS MARCOand TREC CAR) is to feed the queryâ€“document pair through BERTand use an MLP on top of BERTâ€™s [CLS] output token to produce arelevance score. Subsequent work by Nogueira et al. [27] introducedduoBERT, which fine-tunes BERT to compare the relevance of apair of documents given a query. Relative to their single-documentBERT, this gives duoBERT about 1% MRR@10 advantage on MSMARCO while increasing the cost by at least 1.4Ã—.BERT Optimizations. As discussed in Â§1, these rankers can behighly expensive in practice. Orthogonal to our approach, there areongoing efforts in the NLU literature for distilling [ 14,33], compress-ing [ 40], and pruning [ 19] BERT. Other optimizations may tradequality and speed specifically for IR (e.g., re-ranking with a smaller3https://github.com/stanford-futuredata/ColBERTQuery DocumentQuery Encoder, fQ Document Encoder, fDMaxSim MaxSim MaxSimscoreOffline IndexingFigure 3: The general architecture of ColBERT given a queryğ‘and a document ğ‘‘.depthğ‘˜(Â§4.2) or truncating longer documents). While these effortscan be instrumental in narrowing the efficiency gap, they generallyachieve much smaller speedups than our re-designed architecturefor IR, due to their generic nature, and the more aggressive onesoften come at the cost of noticeably lower quality.Efficient NLU-based Models. Recently, a direction emergedthat employs expensive NLU computation offline. This includesdoc2query [ 28] and DeepCT [ 2]. The doc2query model expandseach document with a pre-defined number of synthetic queries, gen-erated by a seq2seq transformer model trained to generate queriesgiven a document. It then relies on a BM25 index for retrieval fromthe (expanded) documents. DeepCT uses BERT to produce the termfrequency component of BM25 in a context-aware manner, essen-tially representing a feasible realization of the term-independenceassumption with neural networks [ 23]. Lastly, docTTTTTquery [ 26]is identical to doc2query except that it fine-tunes a pre-trainedmodel (namely, T5 [31]) for generating the predicted queries.Concurrently with the drafting of this paper, HofstÃ¤tter et al. [11]published their Transformer-Kernel (TK) model. At a high level, TKimproves the KNRM architecture described earlier: while KNRMemploys kernel pooling on top of word-embedding-based inter-action, TK uses a Transformer [ 34] component for contextuallyencoding queries and documents before kernel pooling. TK estab-lishes a new state-of-the-art for non-BERT models on MS MARCO(Dev); however, the best non-ensemble MRR@10 it achieves is 31%while ColBERT reaches up to 36%. Moreover, due to indexing docu-ment representations offline and employing a MaxSim-based lateinteraction mechanism, ColBERT is much more scalable, enablingend-to-end retrieval which is not supported by TK.3 COLBERTColBERT prescribes a simple framework for balancing the qualityand cost of neural IR, particularly deep language models like BERT.As introduced earlier, delaying the queryâ€“document interaction canfacilitate cheap neural re-ranking (i.e., through pre-computation)and even support practical end-to-end neural retrieval (i.e., throughpruning via vector-similarity search). ColBERT addresses how todo so while still preserving the effectiveness of state-of-the-artmodels, which condition the bulk of their computations on the jointqueryâ€“document pair.Session 1A: NeuIR and Semantic Matching  SIGIR â€™20, July 25â€“30, 2020, Virtual Event, China41Even though ColBERTâ€™s late-interaction framework can be ap-plied to a wide variety of architectures (e.g., CNNs, RNNs, transform-ers, etc.), we choose to focus this work on bi-directional transformer-based encoders (i.e., BERT) owing to their state-of-the-art effective-ness yet very high computational cost.3.1 ArchitectureFigure 3 depicts the general architecture of ColBERT, which com-prises: (a) a query encoder ğ‘“ğ‘„, (b) a document encoder ğ‘“ğ·, and (c)the late interaction mechanism. Given a query ğ‘and document ğ‘‘,ğ‘“ğ‘„encodesğ‘into a bag of fixed-size embeddings ğ¸ğ‘whileğ‘“ğ·en-codesğ‘‘into another bag ğ¸ğ‘‘. Crucially, each embeddings in ğ¸ğ‘andğ¸ğ‘‘iscontextualized based on the other terms in ğ‘orğ‘‘, respectively.We describe our BERT-based encoders in Â§3.2.Usingğ¸ğ‘andğ¸ğ‘‘, ColBERT computes the relevance score be-tweenğ‘andğ‘‘via late interaction, which we define as a summationof maximum similarity (MaxSim) operators. In particular, we findthe maximum cosine similarity of each ğ‘£âˆˆğ¸ğ‘with vectors in ğ¸ğ‘‘,and combine the outputs via summation. Besides cosine, we alsoevaluate squared L2 distance as a measure of vector similarity. In-tuitively, this interaction mechanism softly searches for each querytermğ‘¡ğ‘â€”in a manner that reflects its context in the queryâ€”againstthe documentâ€™s embeddings, quantifying the strength of the â€œmatchâ€via the largest similarity score between ğ‘¡ğ‘and a document term ğ‘¡ğ‘‘.Given these term scores, it then estimates the document relevanceby summing the matching evidence across all query terms.While more sophisticated matching is possible with other choicessuch as deep convolution and attention layers (i.e., as in typicalinteraction-focused models), a summation of maximum similaritycomputations has two distinctive characteristics. First, it standsout as a particularly cheap interaction mechanism, as we examineits FLOPs in Â§4.2. Second, and more importantly, it is amenableto highly-efficient pruning for top- ğ‘˜retrieval, as we evaluate inÂ§4.3. This enables using vector-similarity algorithms for skippingdocuments without materializing the full interaction matrix or evenconsidering each document in isolation. Other cheap choices (e.g.,a summation of average similarity scores, instead of maximum) arepossible; however, many are less amenable to pruning. In Â§4.4, weconduct an extensive ablation study that empirically verifies the ad-vantage of our MaxSim-based late interaction against alternatives.3.2 Query & Document EncodersPrior to late interaction, ColBERT encodes each query or documentinto a bag of embeddings, employing BERT-based encoders. Weshare a single BERT model among our query and document en-coders but distinguish input sequences that correspond to queriesand documents by prepending a special token [Q]to queries andanother token [D]to documents.Query Encoder. Given a textual query ğ‘, we tokenize it into itsBERT-based WordPiece [ 35] tokensğ‘1ğ‘2...ğ‘ğ‘™. We prepend the token[Q]to the query. We place this token right after BERTâ€™s sequence-start token [CLS] . If the query has fewer than a pre-defined numberof tokensğ‘ğ‘, we pad it with BERTâ€™s special [mask] tokens upto lengthğ‘ğ‘(otherwise, we truncate it to the first ğ‘ğ‘tokens).This padded sequence of input tokens is then passed into BERTâ€™sdeep transformer architecture, which computes a contextualizedrepresentation of each token.We denote the padding with masked tokens as query augmen-tation , a step that allows BERT to produce query-based embeddingsat the positions corresponding to these masks. Query augmentationis intended to serve as a soft, differentiable mechanism for learningto expand queries with new terms or to re-weigh existing termsbased on their importance for matching the query. As we show inÂ§4.4, this operation is essential for ColBERTâ€™s effectiveness.Given BERTâ€™s representation of each token, our encoder passesthe contextualized output representations through a linear layerwith no activations. This layer serves to control the dimension ofColBERTâ€™s embeddings, producing ğ‘š-dimensional embeddings forthe layerâ€™s output size ğ‘š. As we discuss later, we typically fix ğ‘štobe much smaller than BERTâ€™s fixed hidden dimension.While ColBERTâ€™s embedding dimension has limited impact onthe efficiency of query encoding, this step is crucial for controllingthe space footprint of documents, as we show in Â§4.5. In addition,it can have a significant impact on query execution time, particu-larly the time taken for transferring the document representationsonto the GPU from system memory (where they reside before pro-cessing a query). In fact, as we show in Â§4.2, gathering, stacking,and transferring the embeddings from CPU to GPU can be themost expensive step in re-ranking with ColBERT. Finally, the out-put embeddings are normalized so each has L2 norm equal to one.The result is that the dot-product of any two embeddings becomesequivalent to their cosine similarity, falling in the [âˆ’1,1]range.Document Encoder. Our document encoder has a very similararchitecture. We first segment a document ğ‘‘into its constituenttokensğ‘‘1ğ‘‘2...ğ‘‘ğ‘š, to which we prepend BERTâ€™s start token [CLS] fol-lowed by our special token [D]that indicates a document sequence.Unlike queries, we do not append [mask] tokens to documents. Af-ter passing this input sequence through BERT and the subsequentlinear layer, the document encoder filters out the embeddings corre-sponding to punctuation symbols, determined via a pre-defined list.This filtering is meant to reduce the number of embeddings per doc-ument, as we hypothesize that (even contextualized) embeddingsof punctuation are unnecessary for effectiveness.In summary, given ğ‘=ğ‘0ğ‘1...ğ‘ğ‘™andğ‘‘=ğ‘‘0ğ‘‘1...ğ‘‘ğ‘›, we computethe bags of embeddings ğ¸ğ‘andğ¸ğ‘‘in the following manner, where#refers to the [mask] tokens:ğ¸ğ‘:=Normalize(CNN(BERT(â€œ[ğ‘„]ğ‘0ğ‘1...ğ‘ğ‘™##...#â€))) (1)ğ¸ğ‘‘:=Filter(Normalize(CNN(BERT(â€œ[ğ·]ğ‘‘0ğ‘‘1...ğ‘‘ğ‘›â€)))) (2)3.3 Late InteractionGiven the representation of a query ğ‘and a document ğ‘‘, the rele-vance score of ğ‘‘toğ‘, denoted asğ‘†ğ‘,ğ‘‘, is estimated via late interactionbetween their bags of contextualized embeddings. As mentionedbefore, this is conducted as a sum of maximum similarity computa-tions, namely cosine similarity (implemented as dot-products dueto the embedding normalization) or squared L2 distance.ğ‘†ğ‘,ğ‘‘:=Ã•ğ‘–âˆˆ[|ğ¸ğ‘|]maxğ‘—âˆˆ[|ğ¸ğ‘‘|]ğ¸ğ‘ğ‘–Â·ğ¸ğ‘‡ğ‘‘ğ‘—(3)Session 1A: NeuIR and Semantic Matching  SIGIR â€™20, July 25â€“30, 2020, Virtual Event, China42ColBERT is differentiable end-to-end. We fine-tune the BERTencoders and train from scratch the additional parameters (i.e., thelinear layer and the [Q] and [D] markersâ€™ embeddings) using theAdam [ 16] optimizer. Notice that our interaction mechanism hasno trainable parameters. Given a triple âŸ¨ğ‘,ğ‘‘+,ğ‘‘âˆ’âŸ©with query ğ‘,positive document ğ‘‘+and negative document ğ‘‘âˆ’, ColBERT is usedto produce a score for each document individually and is optimizedvia pairwise softmax cross-entropy loss over the computed scoresofğ‘‘+andğ‘‘âˆ’.3.4 Offline Indexing: Computing & StoringDocument EmbeddingsBy design, ColBERT isolates almost all of the computations be-tween queries and documents to enable pre-computing documentrepresentations offline. At a high level, our indexing procedure isstraight-forward: we proceed over the documents in the collectionin batches, running our document encoder ğ‘“ğ·on each batch andstoring the output embeddings per document. Although indexing aset of documents is an offline process, we incorporate a few simpleoptimizations for enhancing its throughput. As we show in Â§4.5,these can considerably reduce the offline cost of indexing.To begin with, we exploit multiple GPUs, if available, for fasterencoding of batches of documents in parallel. When batching, wepad all documents to the maximum length of a document withinthe batch.4To make capping the sequence length on a per-batchbasis effective, our indexer proceeds through documents in largegroups ofğµ(e.g.,ğµ=100,000) documents. It sorts these documentsby length and then feeds batches of ğ‘(e.g.,ğ‘=128) documents ofcomparable length through our encoder. Such length-based bucket-ing is sometimes refered to as a BucketIterator in some libraries(e.g., allenNLP). Lastly, while most computations occur on the GPU,we found that a non-trivial portion of the indexing time is spent onpre-processing the text sequences, primarily BERTâ€™s WordPiece to-kenization. Exploiting that these operations are independent acrossdocuments in a batch, we parallelize the pre-processing across theavailable CPU cores.Once the document representations are produced, they are savedto disk using 32-bit or 16-bit values to represent each dimension.As we describe in Â§3.5 and 3.6, these representations are eithersimply loaded from disk for ranking or are subsequently indexedfor vector-similarity search, respectively.3.5 Top-ğ‘˜Re-ranking with ColBERTRecall that ColBERT can be used for re-ranking the output of an-other retrieval model, typically a term-based model, or directlyfor end-to-end retrieval from a document collection. In this sec-tion, we discuss how we use ColBERT for ranking a small set ofğ‘˜(e.g.,ğ‘˜=1000) documents given a query ğ‘. Sinceğ‘˜is small, werely on batch computations to exhaustively score each document(unlike our approach in Â§3.6). To begin with, our query serving sub-system loads the indexed documents representations into memory,representing each document as a matrix of embeddings.Given a query ğ‘, we compute its bag of contextualized embed-dingsğ¸ğ‘(Equation 1) and, concurrently, gather the document repre-sentations into a 3-dimensional tensor ğ·consisting of ğ‘˜document4The public BERT implementations we saw simply pad to a pre-defined length.matrices. We pad the ğ‘˜documents to their maximum length tofacilitate batched operations, and move the tensor ğ·to the GPUâ€™smemory. On the GPU, we compute a batch dot-product of ğ¸ğ‘andğ·, possibly over multiple mini-batches. The output materializes a3-dimensional tensor that is a collection of cross-match matricesbetweenğ‘and each document. To compute the score of each docu-ment, we reduce its matrix across document terms via a max-pool(i.e., representing an exhaustive implementation of our MaxSimcomputation) and reduce across query terms via a summation. Fi-nally, we sort the ğ‘˜documents by their total scores.Relative to existing neural rankers (especially, but not exclusively,BERT-based ones), this computation is very cheap that, in fact, thecost of a simple implementation is dominated by the gatheringand transferring of the pre-computed embeddings. To illustrate,rankingğ‘˜documents via typical BERT rankers requires feedingBERTğ‘˜different inputs each of length ğ‘™=|ğ‘|+|ğ‘‘ğ‘–|for queryğ‘anddocumentsğ‘‘ğ‘–, where attention has quadratic cost in the length ofthe sequence. In contrast, ColBERT feeds BERT only a single, muchshorter sequence of length ğ‘™=|ğ‘|. Consequently, ColBERT is notonly cheaper, it also scales much better with ğ‘˜(Â§4.2).3.6 End-to-end Top- ğ‘˜Retrieval with ColBERTAs mentioned before, ColBERTâ€™s late-interaction operator is specifi-cally designed to enable end-to-end retrieval from a large collection,largely to improve recall relative to term-based retrieval approaches.This section is concerned with cases where the number of docu-ments to be ranked is too large for exhaustive evaluation of eachpossible candidate document, particularly when we are only in-terested in the highest scoring ones. Concretely, we focus here onretrieving the top- ğ‘˜results directly from a large document collec-tion withğ‘(e.g.,ğ‘=10,000,000) documents, where ğ‘˜â‰ªğ‘.To do so, we leverage the pruning-friendly nature of the MaxSimoperations at the backbone of late interaction. Instead of applyingMaxSim between one of the query embeddings and all of one docu-mentâ€™s embeddings, we can use fast vector-similarity data structuresto efficiently conduct this search between the query embeddingandalldocument embeddings across the full collection. For this,we employ an off-the-shelf library for large-scale vector-similaritysearch, namely faiss [15] from Facebook.5In particular, at theend of offline indexing (Â§3.4), we maintain a mapping from eachembedding to its document of origin and then index all documentembeddings into faiss.Subsequently, when serving queries, we use a two-stage pro-cedure to retrieve the top- ğ‘˜documents from the entire collection.Both stages rely on ColBERTâ€™s scoring: the first is an approximatestage aimed at filtering while the second is a refinement stage. Forthe first stage, we concurrently issue ğ‘ğ‘vector-similarity queries(corresponding to each of the embeddings in ğ¸ğ‘) onto our faiss in-dex. This retrieves the top- ğ‘˜â€²(e.g.,ğ‘˜â€²=ğ‘˜/2) matches for that vectorover all document embeddings. We map each of those to its docu-ment of origin, producing ğ‘ğ‘Ã—ğ‘˜â€²document IDs, only ğ¾â‰¤ğ‘ğ‘Ã—ğ‘˜â€²of which are unique. These ğ¾documents likely contain one or moreembeddings that are highly similar to the query embeddings. Forthe second stage, we refine this set by exhaustively re-ranking onlythoseğ¾documents in the usual manner described in Â§3.5.5https://github.com/facebookresearch/faissSession 1A: NeuIR and Semantic Matching  SIGIR â€™20, July 25â€“30, 2020, Virtual Event, China43In our faiss -based implementation, we use an IVFPQ index(â€œinverted file with product quantizationâ€). This index partitionsthe embedding space into ğ‘ƒ(e.g.,ğ‘ƒ=1000) cells based on ğ‘˜-meansclustering and then assigns each document embedding to its nearestcell based on the selected vector-similarity metric. For servingqueries, when searching for the top- ğ‘˜â€²matches for a single queryembedding, only the nearest ğ‘(e.g.,ğ‘=10) partitions are searched.To improve memory efficiency, every embedding is divided into ğ‘ (e.g.,ğ‘ =16) sub-vectors, each represented using one byte. Moreover,the index conducts the similarity computations in this compresseddomain, leading to cheaper computations and thus faster search.4 EXPERIMENTAL EVALUATIONWe now turn our attention to empirically testing ColBERT, address-ing the following research questions.RQ1: In a typical re-ranking setup, how well can ColBERT bridgethe existing gap (highlighted in Â§1) between highly-efficient andhighly-effective neural models? (Â§4.2)RQ2: Beyond re-ranking, can ColBERT effectively support end-to-end retrieval directly from a large collection? (Â§4.3)RQ3: What does each component of ColBERT (e.g., late interac-tion, query augmentation) contribute to its quality? (Â§4.4)RQ4: What are ColBERTâ€™s indexing-related costs in terms ofoffline computation and memory overhead? (Â§4.5)4.1 Methodology4.1.1 Datasets & Metrics. Similar to related work [ 2,27,28], weconduct our experiments on the MS MARCO Ranking [ 24] (hence-forth, MS MARCO) and TREC Complex Answer Retrieval (TREC-CAR) [ 6] datasets. Both of these recent datasets provide large train-ing data of the scale that facilitates training and evaluating deepneural networks. We describe both in detail below.MS MARCO. MS MARCO is a dataset (and a correspondingcompetition) introduced by Microsoft in 2016 for reading compre-hension and adapted in 2018 for retrieval. It is a collection of 8.8Mpassages from Web pages, which were gathered from Bingâ€™s re-sults to 1M real-world queries. Each query is associated with sparserelevance judgements of one (or very few) documents marked asrelevant and no documents explicitly indicated as irrelevant. Perthe official evaluation, we use MRR@10 to measure effectiveness.We use three query sets in our evaluation. The official develop-ment and evaluation sets contain roughly 7k queries. The relevancejudgements of the evaluation set are held-out by Microsoft andMRR@10 results can only be obtained by submitting to the com-petitionâ€™s organizers. We submitted our main re-ranking ColBERTmodel for Â§4.2. In addition, the collection includes roughly 55kqueries (with labels) that are provided as additional validation data.We re-purpose a random sample of 5k queries among those (i.e.,ones not in our development or training sets) as a â€œlocalâ€ evaluationset. Along with the official development set, we use this held-outset for testing our models as well as baselines in Â§4.3. We do so toavoid submitting multiple variants of the same model at once, asthe organizers discourage too many submissions by the same team.TREC CAR. Introduced by Dietz [ 6]et al. in 2017, TREC CAR isa synthetic dataset based on Wikipedia that consists of about 29Mpassages. Similar to related work [ 25], we dedicate the first fourof five pre-defined folds for training (and the fifth for validation),which amounts to roughly 3M queries generated by concatenatingthe title of a Wikipedia page with the heading of one of its sections.That sectionâ€™s passages are marked as relevant to the correspondingquery. Our evaluation is conducted on the test set used in TREC2017 CAR, which contains 2,254 queries.4.1.2 Implementation. Our ColBERT models are implemented us-ing Python 3 and PyTorch 1. We use the popular transformers6library for pre-trained BERT. Similar to [ 25], we fine-tune all Col-BERT models with learning rate 3Ã—10âˆ’6with a batch size 32. We fixthe number of embeddings per query at ğ‘ğ‘=32. Unless otherwisestated, we set our ColBERT embedding dimension ğ‘što 128; Â§4.5demonstrates ColBERTâ€™s robustness to a wide range of dimensions.For MS MARCO, we initialize the BERT components of the Col-BERT query and document encoders using Googleâ€™s official pre-trained BERT basemodel and train all models for 200k iterations.For TREC CAR, we follow related work [ 2,25] and use a differentpre-trained model to the official ones. To explain, the official BERTmodels were pre-trained on Wikipedia, which is the source of TRECCARâ€™s training and test sets. To avoid leaking test data into train,Nogueira and Cho [ 25] pre-train a BERT model on the Wiki pagescorresponding to training subset of TREC CAR. They release theirBERT large pre-trained model, which we fine-tune for ColBERTâ€™s ex-periments on TREC CAR. As BERT large embeddings are larger, wesetğ‘što 200, and since fine-tuning this model is significantly slowerthan BERT base, we train on TREC CAR for only 125k iterations.In our re-ranking results, unless otherwise stated, we use 4 bytesper dimension in our embeddings and employ cosine as our vector-similarity function. For end-to-end ranking, we use (squared) L2distance, as we found our faiss index was faster at L2-based re-trieval. For our faiss index, we set the number of partitions toğ‘ƒ=2,000, and search the nearest ğ‘=10to each query embedding toretrieveğ‘˜â€²=ğ‘˜=1000 document vectors per query embedding. Wedivide each embedding into ğ‘ =16sub-vectors, each encoded usingone byte. To represent the index used for the second stage of ourend-to-end retrieval procedure, we use 16-bit values per dimension.4.1.3 Hardware & Time Measurements. To evaluate the latency ofneural re-ranking models in Â§4.2, we use a single Tesla V100 GPUthat has 32 GiBs of memory on a server with two Intel Xeon Gold6132 CPUs, each with 14 physical cores (24 hyperthreads), and 469GiBs of RAM. For the mostly CPU-based retrieval experiments inÂ§4.3 and the indexing experiments in Â§4.5, we use another serverwith the same CPU and system memory specifications but whichhas four Titan V GPUs attached, each with 12 GiBs of memory.Across all experiments, only one GPU is dedicated per query forretrieval (i.e., for methods with neural computations) but we useup to all four GPUs during indexing.4.2 Qualityâ€“Cost Tradeoff: Top- ğ‘˜Re-rankingIn this section, we examine ColBERTâ€™s efficiency and effectivenessat re-ranking the top- ğ‘˜results extracted by a bag-of-words retrievalmodel, which is the most typical setting for testing and deployingneural ranking models. We begin with the MS MARCO dataset. We6https://github.com/huggingface/transformersSession 1A: NeuIR and Semantic Matching  SIGIR â€™20, July 25â€“30, 2020, Virtual Event, China44Method MRR@10 (Dev) MRR@10 (Eval) Re-ranking Latency (ms) FLOPs/queryBM25 (official) 16.7 16.5 - -KNRM 19.8 19.8 3 592M (0.085Ã—)Duet 24.3 24.5 22 159B (23Ã—)fastText+ConvKNRM 29.0 27.7 28 78B (11Ã—)BERT base[25] 34.7 - 10,700 97T (13,900Ã—)BERT base(our training) 36.0 - 10,700 97T (13,900Ã—)BERT large [25] 36.5 35.9 32,900 340T (48,600Ã—)ColBERT (over BERT base) 34.9 34.9 61 7B (1Ã—)Table 1: â€œRe-rankingâ€ results on MS MARCO. Each neural model re-ranks the official top-1000 results produced by BM25.Latency is reported for re-ranking only. To obtain the end-to-end latency in Figure 1, we add the BM25 latency from Table 2.Method MRR@10 (Dev) MRR@10 (Local Eval) Latency (ms) Recall@50 Recall@200 Recall@1000BM25 (official) 16.7 - - - - 81.4BM25 (Anserini) 18.7 19.5 62 59.2 73.8 85.7doc2query 21.5 22.8 85 64.4 77.9 89.1DeepCT 24.3 - 62(est.) 69 [2] 82 [2] 91 [2]docTTTTTquery 27.7 28.4 87 75.6 86.9 94.7ColBERT L2(re-rank) 34.8 36.4 - 75.3 80.5 81.4ColBERT L2(end-to-end) 36.0 36.7 458 82.9 92.3 96.8Table 2: End-to-end retrieval results on MS MARCO. Each model retrieves the top-1000 documents per query directly from theentire 8.8M document collection.compare against KNRM, Duet, and fastText+ConvKNRM, a repre-sentative set of neural matching models that have been previouslytested on MS MARCO. In addition, we compare against the adapta-tion of BERT for ranking by Nogueira and Cho [ 25], in particular,their BERT baseand its deeper counterpart BERT large.7We report the competitionâ€™s official metric, namely MRR@10, onthe validation set (Dev) and the evaluation set (Eval). We also reportthe re-ranking latency, which we measure using a single Tesla V100GPU, and the FLOPs per query for each neural ranking model. To doso, we adapt the baselinesâ€™ publicly-available reference implemen-tations into our pytorch testbed. For ColBERT, our reported latencysubsumes the entire computation from gathering the documentrepresentations, moving them to the GPU, tokenizing then encod-ing the query, and applying late interaction to compute documentscores. For the baselines, we measure the scoring computations onthe GPU and exclude the CPU-based text preprocessing (similarto [9]). In principle, the baselines can pre-compute most of thispreprocessing (e.g., document tokenization) offline. We estimatethe FLOPs using the torchprofile8library.We now proceed to study the results, which are reported in Ta-ble 1. To begin with, we notice the fast progress from KNRM in2017 to the BERT-based models in 2019, manifesting itself in over16% increase in MRR@10. As described in Â§1, the simultaneousincrease in computational cost is difficult to miss. Judging by theirrather monotonic pattern of increasingly larger cost and higher ef-fectiveness, these results appear to paint a picture where expensivemodels are necessary for high-quality ranking.In contrast with this trend, ColBERT (which employs late in-teraction over BERT base) performs competitively with the original7https://github.com/nyu-dl/dl4marco-bert/8https://github.com/mit-han-lab/torchprofileadaptation of BERT baseand BERT large for ranking by Nogueiraand Cho [ 25,27]. Interestingly, ColBERT appears no worse thanBERT basein MRR@10â€”although the latter uses a different loss func-tion to ColBERTâ€™s (Â§3.3). To confirm the intuition that ColBERTâ€™slate interaction does trade away some of BERTâ€™s quality, the tablealso reports results of â€œBERT base(our training)â€, which is based onNogueira and Choâ€™s model of the same size but is optimized withpairwise softmax cross-entropy loss. We train it with learning rate3Ã—10âˆ’6and batch size 16 for 200k iterations. Unlike the originalBERT baseranker, results show that this model does in fact have anedge over ColBERTâ€™s effectiveness.While highly competitive in retrieval quality, ColBERT is ordersof magnitude cheaper than BERT base, in particular, by over 170 Ã—inlatency and 13,900Ã—in FLOPs. This highlights the expressivenessof our proposed late interaction mechanism when coupled with apowerful pre-trained LM like BERT. While ColBERTâ€™s re-rankinglatency is slightly higher than the non-BERT models shown (i.e., by10s of milliseconds), this difference is explained by the time it takesa simple Python implementation to gather, stack, and transfer thedocument embeddings to the GPU. In particular, the query encodingand interaction in ColBERT consume only 13 milliseconds of itstotal execution time.Diving deeper into the qualityâ€“cost tradeoff between BERT andColBERT, Figure 4 demonstrates the relationships between FLOPsand effectiveness (MRR@10) as a function of the re-ranking depthğ‘˜when re-ranking the top- ğ‘˜results by BM25, comparing ColBERTand BERT base(our training). We conduct this experiment on MSMARCO (Dev). We note here that as the official top-1000 rankingdoes not provide the BM25 order (and also lacks documents beyondthe top-1000 per query), the models in this experiment re-rank theSession 1A: NeuIR and Semantic Matching  SIGIR â€™20, July 25â€“30, 2020, Virtual Event, China450.27 0.29 0.31 0.33 0.35 0.37MRR@10103104105106107108109Million FLOPs (log-scale)k=10205010020050010002000k=10 20 50 10020050010002000BERTbase (our training)ColBERTFigure 4: FLOPs (in millions) and MRR@10 as functionsof the re-ranking depth ğ‘˜. Since the official BM25 rankingis not ordered, the initial top- ğ‘˜retrieval is conducted withAnseriniâ€™s BM25.Anserini [ 37] toolkitâ€™s BM25 output. Consequently, both MRR@10values atğ‘˜=1000 are slightly higher from those reported in Table 1.Studying the results in Figure 4, we notice that not only is Col-BERT much cheaper than BERT for the same model size (i.e., 12-layer â€œbaseâ€ transformer encoder), it also scales better with thenumber of ranked documents. In part, this is because ColBERTonly needs to process the query once, irrespective of the number ofdocuments evaluated. For instance, at ğ‘˜=10, BERT requires nearly180Ã—more FLOPs than ColBERT; at ğ‘˜=1000, BERTâ€™s overheadjumps to 13,900Ã—. It then reaches 23,000Ã— atğ‘˜=2000.We observe that this orders-of-magnitude reduction in FLOPsmakes it practical to run ColBERT entirely on the CPU. In fact, sub-sequent informal experimentation suggests that ColBERTâ€™s latencyand FLOPs can be considerably reduced further by a number ofoptimizations, some entailing a controllable quality tradeoff. Theseinclude using smaller vector dimensions (whose MRR@10 is testedin Â§4.5), padding queries to shorter ğ‘ğ‘, processing documents ina lengths-aware fashion, and distilling/quantizing the encoder(s)(Â§2), the final two of which are also applicable to the baseline BERTreference implementation by Nogueira and Cho [ 25]. Addition-ally, caching the document embeddings on the GPU(s)â€”if sufficientGPU memory existsâ€”can significantly reduce ColBERTâ€™s latency.Lastly, batch-processing of multiple queries can enhance ColBERTâ€™sthroughput by improving the GPU utilization of query encoding.We leave exploring these opportunities for future work.Method MAP MRR@10BM25 (Anserini) 15.3 -doc2query 18.1 -DeepCT 24.6 33.2BM25 + BERT base 31.0 -BM25 + BERT large 33.5 -BM25 + ColBERT 31.3 44.2Table 3: Results on TREC CAR.Having studied our results on MS MARCO, we now considerTREC CAR, whose official metric is MAP. Similar to Table 1, wealso report MRR@10. The results are summarized in Table 3, whichincludes a number of important baselines (BM25, doc2query, andDeepCT) in addition to re-ranking baselines that have previouslybeen tested on this dataset. As the table shows, the results mirrorthose seen with MS MARCO.4.3 End-to-end Top- ğ‘˜RetrievalBeyond cheap re-ranking, ColBERT is amenable to top- ğ‘˜retrieval di-rectly from a full collection. Table 2 considers full retrieval, whereineach model retrieves the top-1000 documents directly from MSMARCOâ€™s 8.8M documents per query. In addition to MRR@10 andlatency in milliseconds, the table reports Recall@50, Recall@200,and Recall@1000, important metrics for a full-retrieval model thatessentially filters down a large collection on a per-query basis.We compare against BM25, in particular MS MARCOâ€™s officialBM25 ranking as well as a well-tuned baseline based on the Anserinitoolkit.9While many other traditional models exist, we are notaware of any that substantially outperform Anseriniâ€™s BM25 im-plementation (e.g., see RM3 in [ 28], LMDir in [ 2], or Microsoftâ€™sproprietary feature-based RankSVM on the leaderboard).We also compare against doc2query, DeepCT, and docTTTTT-query. All three rely on a traditional bag-of-words model (primarilyBM25) for retrieval. Crucially, however, they re-weigh the frequencyof terms per document and/or expand the set of terms in each doc-ument before building the BM25 index. In particular, doc2queryexpands each document with a pre-defined number of syntheticqueries generated by a seq2seq transformer model (which docTTT-Tquery replaced with a pre-trained language model, T5 [ 31]). Incontrast, DeepCT uses BERT to produce the term frequency com-ponent of BM25 in a context-aware manner.For the latency of Anseriniâ€™s BM25, doc2query, and docTTTT-query, we use the authorsâ€™ [ 26,28] Anserini-based implementation.While this implementation supports multi-threading, it only utilizesparallelism across different queries. We thus report single-threadedlatency for these models, noting that simply parallelizing their com-putation over shards of the index can substantially decrease theiralready-low latency. For DeepCT, we only estimate its latency us-ing that of BM25 (as denoted by (est.) in the table), since DeepCTre-weighs BM25â€™s term frequency without modifying the indexotherwise.10As discussed in Â§4.1, we use ColBERT L2for end-to-end retrieval, which employs negative squared L2 distance as itsvector-similarity function. For its latency, we measure the time forfaiss -based candidate filtering and the subsequent re-ranking. Inthis experiment, faiss uses all available CPU cores.Looking at Table 2, we first see Anseriniâ€™s BM25 baseline at 18.7MRR@10, noticing its very low latency as implemented in Anserini(which extends the well-known Lucene system), owing to bothvery cheap operations and decades of bag-of-words top- ğ‘˜retrievaloptimizations. The three subsequent baselines, namely doc2query,DeepCT, and docTTTTquery, each brings a decisive enhancementto effectiveness. These improvements come at negligible overheadsin latency, since these baselines ultimately rely on BM25-basedretrieval. The most effective among these three, docTTTTquery,demonstrates a massive 9% gain over vanilla BM25 by fine-tuningthe recent language model T5.9http://anserini.io/10In practice, a myriad of reasons could still cause DeepCTâ€™s latency to differslightly from BM25â€™s. For instance, the top- ğ‘˜pruning strategy employed, if any, couldinteract differently with a changed distribution of scores.Session 1A: NeuIR and Semantic Matching  SIGIR â€™20, July 25â€“30, 2020, Virtual Event, China46Shifting our attention to ColBERTâ€™s end-to-end retrieval effec-tiveness, we see its major gains in MRR@10 over all of these end-to-end models. In fact, using ColBERT in the end-to-end setup is su-perior in terms of MRR@10 to re-ranking with the same model dueto the improved recall. Moving beyond MRR@10, we also see largegains in Recall@ ğ‘˜forğ‘˜equals to 50, 200, and 1000. For instance, itsRecall@50 actually exceeds the official BM25â€™s Recall@1000 andeven all but docTTTTTqueryâ€™s Recall@200, emphasizing the valueof end-to-end retrieval (instead of just re-ranking) with ColBERT.4.4 Ablation Studies0.220.240.260.280.300.320.340.36MRR@10BERT [CLS]-based dot-product (5-layer)  [A]ColBERT via average similarity (5-layer)  [B]ColBERT without query augmentation (5-layer)  [C]ColBERT (5-layer)  [D]ColBERT (12-layer)  [E]ColBERT + e2e retrieval (12-layer)  [F]Figure 5: Ablation results on MS MARCO (Dev). Betweenbrackets is the number of BERT layers used in each model.The results from Â§4.2 indicate that ColBERT is highly effectivedespite the low cost and simplicity of its late interaction mechanism.To better understand the source of this effectiveness, we examine anumber of important details in ColBERTâ€™s interaction and encoderarchitecture. For this ablation, we report MRR@10 on the validationset of MS MARCO in Figure 5, which shows our main re-rankingColBERT model [E], with MRR@10 of 34.9%.Due to the cost of training all models, we train a copy of ourmain model that retains only the first 5 layers of BERT out of 12(i.e., model [D]) and similarly train all our ablation models for200k iterations with five BERT layers. To begin with, we ask if thefine-granular interaction in late interaction is necessary. Model [A]tackles this question: it uses BERT to produce a single embeddingvector for the query and another for the document, extracted fromBERTâ€™s [CLS] contextualized embedding and expanded through alinear layer to dimension 4096 (which equals ğ‘ğ‘Ã—128=32Ã—128).Relevance is estimated as the inner product of the queryâ€™s and thedocumentâ€™s embeddings, which we found to perform better thancosine similarity for single-vector re-ranking. As the results show,this model is considerably less effective than ColBERT, reinforcingthe importance of late interaction.Subsequently, we ask if our MaxSim-based late interaction is bet-ter than other simple alternatives. We test a model [B] that replacesColBERTâ€™s maximum similarity with average similarity. The resultssuggest the importance of individual terms in the query payingspecial attention to particular terms in the document. Similarly,the figure emphasizes the importance of our query augmentationmechanism: without query augmentation [C], ColBERT has a no-ticeably lower MRR@10. Lastly, we see the impact of end-to-endretrieval not only on recall but also on MRR@10. By retrievingdirectly from the full collection, ColBERT is able to retrieve to thetop-10 documents missed entirely from BM25â€™s top-1000.4.5 Indexing Throughput & FootprintLastly, we examine the indexing throughput and space footprintof ColBERT. Figure 6 reports indexing throughput on MS MARCO0 10000 20000 30000 40000 50000Throughput (documents/minute)Basic ColBERT Indexing+multi-GPU document processing+per-batch maximum sequence length+length-based bucketing+multi-core pre-processingFigure 6: Effect of ColBERTâ€™s indexing optimizations on theoffline indexing throughput.documents with ColBERT and four other ablation settings, whichindividually enable optimizations described in Â§3.4 on top of basicbatched indexing. Based on these throughputs, ColBERT can indexMS MARCO in about three hours. Note that any BERT-based modelmust incur the computational cost of processing each documentat least once. While ColBERT encodes each document with BERTexactly once, existing BERT-based rankers would repeat similarcomputations on possibly hundreds of documents for each query.Setting Dimension( ğ‘š) Bytes/Dim Space(GiBs) MRR@10Re-rank Cosine 128 4 286 34.9End-to-end L2 128 2 154 36.0Re-rank L2 128 2 143 34.8Re-rank Cosine 48 4 54 34.4Re-rank Cosine 24 2 27 33.9Table 4: Space Footprint vs MRR@10 (Dev) on MS MARCO.Table 4 reports the space footprint of ColBERT under varioussettings as we reduce the embeddings dimension and/or the bytesper dimension. Interestingly, the most space-efficient setting, thatis, re-ranking with cosine similarity with 24-dimensional vectorsstored as 2-byte floats, is only 1% worse in MRR@10 than the mostspace-consuming one, while the former requires only 27 GiBs torepresent the MS MARCO collection.5 CONCLUSIONSIn this paper, we introduced ColBERT, a novel ranking model thatemploys contextualized late interaction over deep LMs (in particular,BERT) for efficient retrieval. By independently encoding queriesand documents into fine-grained representations that interact viacheap and pruning-friendly computations, ColBERT can leveragethe expressiveness of deep LMs while greatly speeding up queryprocessing. Crucially, doing so allows scaling ColBERT to end-to-end neural retrieval directly from a large document collection,which can greatly improve recall over existing models. Our resultsshow that ColBERT is two orders-of-magnitude faster than existingBERT-based models, all while only minimally impacting re-rankingquality and while outperforming every non-BERT baseline.Acknowledgments. OK was supported by the Eltoukhy FamilyGraduate Fellowship at the Stanford School of Engineering. Thisresearch was supported in part by affiliate members and othersupporters of the Stanford DAWN projectâ€”Ant Financial, Facebook,Google, Infosys, NEC, and VMwareâ€”as well as Cisco, SAP, and theNSF under CAREER grant CNS-1651570. Any opinions, findings,and conclusions or recommendations expressed in this material arethose of the authors and do not necessarily reflect the views of theNational Science Foundation.Session 1A: NeuIR and Semantic Matching  SIGIR â€™20, July 25â€“30, 2020, Virtual Event, China47REFERENCES[1]Firas Abuzaid, Geet Sethi, Peter Bailis, and Matei Zaharia. 2019. To Index or Notto Index: Optimizing Exact Maximum Inner Product Search. In 2019 IEEE 35thInternational Conference on Data Engineering (ICDE). IEEE, 1250â€“1261.[2]Zhuyun Dai and Jamie Callan. 2019. Context-Aware Sentence/Passage TermImportance Estimation For First Stage Retrieval. arXiv preprint arXiv:1910.10687(2019).[3]Zhuyun Dai and Jamie Callan. 2019. Deeper Text Understanding for IR withContextual Neural Language Modeling. arXiv preprint arXiv:1905.09217 (2019).[4]Zhuyun Dai, Chenyan Xiong, Jamie Callan, and Zhiyuan Liu. 2018. Convolutionalneural networks for soft-matching n-grams in ad-hoc search. In Proceedings of theeleventh ACM international conference on web search and data mining. 126â€“134.[5]Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. 2018. Bert:Pre-training of deep bidirectional transformers for language understanding. arXivpreprint arXiv:1810.04805 (2018).[6]Laura Dietz, Manisha Verma, Filip Radlinski, and Nick Craswell. 2017. TRECComplex Answer Retrieval Overview.. In TREC.[7]Jiafeng Guo, Yixing Fan, Qingyao Ai, and W Bruce Croft. 2016. A deep relevancematching model for ad-hoc retrieval. In Proceedings of the 25th ACM Internationalon Conference on Information and Knowledge Management. ACM, 55â€“64.[8]Jiafeng Guo, Yixing Fan, Liang Pang, Liu Yang, Qingyao Ai, Hamed Zamani, ChenWu, W Bruce Croft, and Xueqi Cheng. 2019. A deep look into neural rankingmodels for information retrieval. arXiv preprint arXiv:1903.06902 (2019).[9]Sebastian HofstÃ¤tter and Allan Hanbury. 2019. Letâ€™s measure run time! Extendingthe IR replicability infrastructure to include performance aspects. arXiv preprintarXiv:1907.04614 (2019).[10] Sebastian HofstÃ¤tter, Navid Rekabsaz, Carsten Eickhoff, and Allan Hanbury. 2019.On the effect of low-frequency terms on neural-IR models. In Proceedings ofthe 42nd International ACM SIGIR Conference on Research and Development inInformation Retrieval. 1137â€“1140.[11] Sebastian HofstÃ¤tter, Markus Zlabinger, and Allan Hanbury. 2019. TU Wien@TREC Deep Learningâ€™19â€“Simple Contextualization for Re-ranking. arXiv preprintarXiv:1912.01385 (2019).[12] Po-Sen Huang, Xiaodong He, Jianfeng Gao, Li Deng, Alex Acero, and LarryHeck. 2013. Learning deep structured semantic models for web search usingclickthrough data. In Proceedings of the 22nd ACM international conference onInformation & Knowledge Management. 2333â€“2338.[13] Shiyu Ji, Jinjin Shao, and Tao Yang. 2019. Efficient Interaction-based NeuralRanking with Locality Sensitive Hashing. In The World Wide Web Conference.ACM, 2858â€“2864.[14] Xiaoqi Jiao, Yichun Yin, Lifeng Shang, Xin Jiang, Xiao Chen, Linlin Li, Fang Wang,and Qun Liu. 2019. Tinybert: Distilling bert for natural language understanding.arXiv preprint arXiv:1909.10351 (2019).[15] Jeff Johnson, Matthijs Douze, and HervÃ© JÃ©gou. 2017. Billion-scale similaritysearch with GPUs. arXiv preprint arXiv:1702.08734 (2017).[16] Diederik P Kingma and Jimmy Ba. 2014. Adam: A method for stochastic opti-mization. arXiv preprint arXiv:1412.6980 (2014).[17] Ron Kohavi, Alex Deng, Brian Frasca, Toby Walker, Ya Xu, and Nils Pohlmann.2013. Online controlled experiments at large scale. In SIGKDD.[18] Sean MacAvaney, Andrew Yates, Arman Cohan, and Nazli Goharian. 2019. Cedr:Contextualized embeddings for document ranking. In Proceedings of the 42ndInternational ACM SIGIR Conference on Research and Development in InformationRetrieval. ACM, 1101â€“1104.[19] Paul Michel, Omer Levy, and Graham Neubig. 2019. Are Sixteen Heads ReallyBetter than One?. In Advances in Neural Information Processing Systems . 14014â€“14024.[20] Bhaskar Mitra and Nick Craswell. 2019. An Updated Duet Model for PassageRe-ranking. arXiv preprint arXiv:1903.07666 (2019).[21] Bhaskar Mitra, Nick Craswell, et al .2018. An introduction to neural informationretrieval. Foundations and TrendsÂ® in Information Retrieval 13, 1 (2018), 1â€“126.[22] Bhaskar Mitra, Fernando Diaz, and Nick Craswell. 2017. Learning to match usinglocal and distributed representations of text for web search. In Proceedings of the26th International Conference on World Wide Web. International World Wide WebConferences Steering Committee, 1291â€“1299.[23] Bhaskar Mitra, Corby Rosset, David Hawking, Nick Craswell, Fernando Diaz,and Emine Yilmaz. 2019. Incorporating query term independence assumptionfor efficient retrieval and ranking using deep neural networks. arXiv preprintarXiv:1907.03693 (2019).[24] Tri Nguyen, Mir Rosenberg, Xia Song, Jianfeng Gao, Saurabh Tiwary, RanganMajumder, and Li Deng. 2016. MS MARCO: A Human-Generated MAchineReading COmprehension Dataset. (2016).[25] Rodrigo Nogueira and Kyunghyun Cho. 2019. Passage Re-ranking with BERT.arXiv preprint arXiv:1901.04085 (2019).[26] Rodrigo Nogueira, Jimmy Lin, and AI Epistemic. 2019. From doc2query todocTTTTTquery. (2019).[27] Rodrigo Nogueira, Wei Yang, Kyunghyun Cho, and Jimmy Lin. 2019. Multi-StageDocument Ranking with BERT. arXiv preprint arXiv:1910.14424 (2019).[28] Rodrigo Nogueira, Wei Yang, Jimmy Lin, and Kyunghyun Cho. 2019. DocumentExpansion by Query Prediction. arXiv preprint arXiv:1904.08375 (2019).[29] Matthew E Peters, Mark Neumann, Mohit Iyyer, Matt Gardner, ChristopherClark, Kenton Lee, and Luke Zettlemoyer. 2018. Deep contextualized wordrepresentations. arXiv preprint arXiv:1802.05365 (2018).[30] Yifan Qiao, Chenyan Xiong, Zhenghao Liu, and Zhiyuan Liu. 2019. Understandingthe Behaviors of BERT in Ranking. arXiv preprint arXiv:1904.07531 (2019).[31] Colin Raffel, Noam Shazeer, Adam Roberts, Katherine Lee, Sharan Narang,Michael Matena, Yanqi Zhou, Wei Li, and Peter J Liu. 2019. Exploring the lim-its of transfer learning with a unified text-to-text transformer. arXiv preprintarXiv:1910.10683 (2019).[32] Stephen E Robertson, Steve Walker, Susan Jones, Micheline M Hancock-Beaulieu,Mike Gatford, et al. 1995. Okapi at TREC-3. NIST Special Publication (1995).[33] Raphael Tang, Yao Lu, Linqing Liu, Lili Mou, Olga Vechtomova, and Jimmy Lin.2019. Distilling task-specific knowledge from BERT into simple neural networks.arXiv preprint arXiv:1903.12136 (2019).[34] Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones,Aidan N Gomez, Åukasz Kaiser, and Illia Polosukhin. 2017. Attention is allyou need. In Advances in neural information processing systems. 5998â€“6008.[35] Yonghui Wu, Mike Schuster, Zhifeng Chen, Quoc V Le, Mohammad Norouzi,Wolfgang Macherey, Maxim Krikun, Yuan Cao, Qin Gao, Klaus Macherey, et al .2016. Googleâ€™s neural machine translation system: Bridging the gap betweenhuman and machine translation. arXiv preprint arXiv:1609.08144 (2016).[36] Chenyan Xiong, Zhuyun Dai, Jamie Callan, Zhiyuan Liu, and Russell Power. 2017.End-to-end neural ad-hoc ranking with kernel pooling. In Proceedings of the 40thInternational ACM SIGIR conference on research and development in informationretrieval. 55â€“64.[37] Peilin Yang, Hui Fang, and Jimmy Lin. 2018. Anserini: Reproducible rankingbaselines using Lucene. Journal of Data and Information Quality (JDIQ) 10, 4(2018), 1â€“20.[38] Wei Yang, Kuang Lu, Peilin Yang, and Jimmy Lin. 2019. Critically Examiningthe" Neural Hype" Weak Baselines and the Additivity of Effectiveness Gainsfrom Neural Ranking Models. In Proceedings of the 42nd International ACM SIGIRConference on Research and Development in Information Retrieval. 1129â€“1132.[39] Zeynep Akkalyoncu Yilmaz, Wei Yang, Haotian Zhang, and Jimmy Lin. 2019.Cross-domain modeling of sentence-level evidence for document retrieval. InProceedings of the 2019 Conference on Empirical Methods in Natural Language Pro-cessing and the 9th International Joint Conference on Natural Language Processing(EMNLP-IJCNLP). 3481â€“3487.[40] Ofir Zafrir, Guy Boudoukh, Peter Izsak, and Moshe Wasserblat. 2019. Q8bert:Quantized 8bit bert. arXiv preprint arXiv:1910.06188 (2019).[41] Hamed Zamani, Mostafa Dehghani, W Bruce Croft, Erik Learned-Miller, andJaap Kamps. 2018. From neural re-ranking to neural ranking: Learning a sparserepresentation for inverted indexing. In Proceedings of the 27th ACM InternationalConference on Information and Knowledge Management. ACM, 497â€“506.[42] Le Zhao. 2012. Modeling and solving term mismatch for full-text retrieval. Ph.D.Dissertation. Carnegie Mellon University.Session 1A: NeuIR and Semantic Matching  SIGIR â€™20, July 25â€“30, 2020, Virtual Event, China48